<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Digit Recognizer</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- We now use TensorFlow.js to run the model in the browser -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.20.0/dist/tf.min.js"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        #canvas-container {
            position: relative;
            width: 280px;
            height: 280px;
            border: 4px solid #4b5563;
            background-color: #000;
            cursor: crosshair;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            border-radius: 12px;
            overflow: hidden;
        }

        #drawing-canvas {
            width: 100%;
            height: 100%;
        }

        .button-group button {
            transition: all 0.2s ease-in-out;
        }

        .button-group button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
        }
    </style>
</head>

<body class="bg-gray-100 flex items-center justify-center p-4 sm:p-8">
    <div class="bg-white rounded-xl shadow-2xl p-6 sm:p-10 text-center w-full max-w-lg space-y-6">
        <h1 class="text-3xl sm:text-4xl font-extrabold text-gray-800">Digit Recognizer</h1>
        <p class="text-gray-600">Draw a single digit (0-9) on the canvas below and click 'Predict'.</p>

        <!-- Canvas for drawing -->
        <div id="canvas-container" class="mx-auto">
            <canvas id="drawing-canvas"></canvas>
        </div>

        <!-- Buttons -->
        <div class="button-group flex flex-col sm:flex-row space-y-4 sm:space-y-0 sm:space-x-4 justify-center mt-6">
            <button id="predict-button"
                class="bg-blue-600 text-white font-bold py-3 px-8 rounded-full shadow-lg hover:bg-blue-700 focus:outline-none focus:ring-4 focus:ring-blue-300">
                Predict
            </button>
            <button id="clear-button"
                class="bg-red-500 text-white font-bold py-3 px-8 rounded-full shadow-lg hover:bg-red-600 focus:outline-none focus:ring-4 focus:ring-red-200">
                Clear
            </button>
        </div>

        <!-- Prediction Result -->
        <div id="result-box" class="mt-8 p-6 bg-gray-200 rounded-lg shadow-inner hidden">
            <h2 class="text-xl font-bold text-gray-700">Prediction:</h2>
            <p id="prediction-text" class="text-5xl font-extrabold text-gray-900 mt-2"></p>
        </div>

        <!-- Loading & Error Messages -->
        <div id="loading-message" class="hidden mt-4 text-sm text-gray-500">
            <p>Loading model...</p>
            <p>Please wait a moment.</p>
        </div>
        <div id="error-message" class="hidden mt-4 text-red-500 font-semibold"></div>
    </div>

    <script>
        // --- Setup and State ---
        const canvas = document.getElementById('drawing-canvas');
        const ctx = canvas.getContext('2d');
        const predictButton = document.getElementById('predict-button');
        const clearButton = document.getElementById('clear-button');
        const resultBox = document.getElementById('result-box');
        const predictionText = document.getElementById('prediction-text');
        const loadingMessage = document.getElementById('loading-message');
        const errorMessage = document.getElementById('error-message');

        let isDrawing = false;
        let model;

        // --- Model Loading ---
        async function loadModel() {
            try {
                loadingMessage.style.display = 'block';
                // The model is hosted on my Vercel.app. This will be publicly available.
                const modelUrl = 'https://number-predict-rouge.vercel.app/model.json';
                model = await tf.loadLayersModel(modelUrl);
                loadingMessage.style.display = 'none';
                console.log('Model loaded successfully!');
            } catch (error) {
                console.error('Error loading model:', error);
                errorMessage.textContent = 'Failed to load the model. Please refresh the page.';
                errorMessage.style.display = 'block';
                loadingMessage.style.display = 'none';
                predictButton.disabled = true;
                clearButton.disabled = true;
            }
        }

        // --- Canvas Drawing Logic ---
        function resizeCanvas() {
            const container = document.getElementById('canvas-container');
            const size = Math.min(container.offsetWidth, container.offsetHeight);
            canvas.width = size;
            canvas.height = size;
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            // Drawing style
            ctx.strokeStyle = '#fff';
            ctx.lineWidth = 15;
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        function startDrawing(e) {
            isDrawing = true;
            draw(e);
        }

        function stopDrawing() {
            isDrawing = false;
            ctx.beginPath();
        }

        function draw(e) {
            if (!isDrawing) return;

            const rect = canvas.getBoundingClientRect();
            const x = (e.clientX || e.touches[0].clientX) - rect.left;
            const y = (e.clientY || e.touches[0].clientY) - rect.top;

            ctx.lineTo(x, y);
            ctx.stroke();
            ctx.beginPath();
            ctx.moveTo(x, y);
        }

        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseout', stopDrawing);
        canvas.addEventListener('mousemove', draw);

        canvas.addEventListener('touchstart', startDrawing);
        canvas.addEventListener('touchend', stopDrawing);
        canvas.addEventListener('touchcancel', stopDrawing);
        canvas.addEventListener('touchmove', draw);

        // --- Prediction Logic ---
        async function predictDigit() {
            if (!model) {
                errorMessage.textContent = 'Model is not loaded yet.';
                errorMessage.style.display = 'block';
                return;
            }

            try {
                // Resize and preprocess the canvas image for the model
                const smallCanvas = document.createElement('canvas');
                smallCanvas.width = 28;
                smallCanvas.height = 28;
                const smallCtx = smallCanvas.getContext('2d');
                smallCtx.drawImage(canvas, 0, 0, 28, 28);
                const imageData = smallCtx.getImageData(0, 0, 28, 28);
                
                // Get the pixel data from the canvas
                const data = imageData.data;
                const grayscaleImage = new Float32Array(28 * 28);
                for (let i = 0; i < data.length / 4; i++) {
                    const grayscaleValue = data[i * 4];
                    // Normalize the pixel value from 0-255 to 0-1
                    grayscaleImage[i] = grayscaleValue / 255;
                }
                
                // Convert the flat array to a 4D tensor with shape [1, 28, 28, 1]
                const tensor = tf.tensor4d(grayscaleImage, [1, 28, 28, 1]);
                
                // Make the prediction
                const predictions = model.predict(tensor);
                const predictionArray = await predictions.data();
                const predictedLabel = predictionArray.indexOf(Math.max(...predictionArray));
                
                // Display the result
                predictionText.textContent = predictedLabel;
                resultBox.style.display = 'block';

                tensor.dispose();
                predictions.dispose();
                
            } catch (error) {
                console.error('Prediction failed:', error);
                errorMessage.textContent = 'Prediction failed: ' + error.message;
                errorMessage.style.display = 'block';
            }
        }

        // --- Clear Canvas Logic ---
        function clearCanvas() {
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            resultBox.style.display = 'none';
            errorMessage.style.display = 'none';
        }

        // --- Event Listeners ---
        predictButton.addEventListener('click', predictDigit);
        clearButton.addEventListener('click', clearCanvas);

        // --- Initial Load ---
        window.onload = loadModel;
    </script>
</body>
</html>
